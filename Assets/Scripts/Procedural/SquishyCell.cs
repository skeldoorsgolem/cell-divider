using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;

/// <summary>
/// Renders the main clickable cell as a procedurally generated polygon mesh
/// with spring-physics vertex deformation — poking it squishes it like a real cell.
///
/// Setup:
///   - Attach to a UI GameObject (inside a Canvas).
///   - The component auto-creates its MeshFilter, MeshRenderer, and PolygonCollider2D.
///   - Wire the OnPointerDown/Up events, OR use the public Poke() method from ClickManager.
///
/// How it works:
///   - A polygon with `vertexCount` vertices is placed around a circle.
///   - Each vertex has a spring: rest position on the circle, current displaced position.
///   - On poke: vertices near the pointer get an inward impulse.
///   - Each frame: spring force pulls vertices back toward rest, damping kills oscillation.
///   - Texture generated by ProceduralCellTexture is mapped onto the mesh as a UV circle.
/// </summary>
[RequireComponent(typeof(MeshFilter))]
[RequireComponent(typeof(MeshRenderer))]
public class SquishyCell : MonoBehaviour, IPointerDownHandler, IPointerUpHandler
{
    [Header("Shape")]
    [SerializeField] private int   vertexCount  = 48;   // ring polygon resolution
    [SerializeField] private float cellRadius   = 120f;  // UI units

    [Header("Spring physics")]
    [SerializeField] private float stiffness    = 300f;
    [SerializeField] private float damping      = 18f;
    [SerializeField] private float pokeStrength = 180f;
    [SerializeField] private float pokeSpread   = 0.5f;  // radians, how wide the poke is

    [Header("Texture")]
    [SerializeField] private int   textureSize  = 256;
    [SerializeField] private int   textureSeed  = 0;

    // Spring state per vertex
    private Vector3[] _restPos;      // rest positions on the circle (local space)
    private Vector3[] _curPos;       // current displaced positions
    private Vector3[] _velocity;     // spring velocity

    private Mesh       _mesh;
    private MeshFilter _mf;

    // ── Lifecycle ────────────────────────────────────────────────────────────

    private void Awake()
    {
        _mf = GetComponent<MeshFilter>();
        BuildMesh();
        ApplyTexture();
    }

    private void Update()
    {
        StepSprings();
        UpdateMesh();
    }

    // ── Build ────────────────────────────────────────────────────────────────

    private void BuildMesh()
    {
        _restPos  = new Vector3[vertexCount + 1];
        _curPos   = new Vector3[vertexCount + 1];
        _velocity = new Vector3[vertexCount + 1];

        // Centre vertex
        _restPos[0] = Vector3.zero;
        _curPos[0]  = Vector3.zero;

        for (int i = 0; i < vertexCount; i++)
        {
            float angle = (float)i / vertexCount * Mathf.PI * 2f;
            float x = Mathf.Cos(angle) * cellRadius;
            float y = Mathf.Sin(angle) * cellRadius;
            _restPos[i + 1] = new Vector3(x, y, 0f);
            _curPos[i + 1]  = _restPos[i + 1];
        }

        _mesh = new Mesh { name = "CellMesh" };
        _mf.mesh = _mesh;

        // UVs: map each vertex position to [0,1] UV space
        var uvs = new Vector2[vertexCount + 1];
        uvs[0] = new Vector2(0.5f, 0.5f);
        for (int i = 0; i < vertexCount; i++)
        {
            float angle = (float)i / vertexCount * Mathf.PI * 2f;
            uvs[i + 1] = new Vector2(
                Mathf.Cos(angle) * 0.5f + 0.5f,
                Mathf.Sin(angle) * 0.5f + 0.5f);
        }

        // Triangles: fan from centre
        var tris = new int[vertexCount * 3];
        for (int i = 0; i < vertexCount; i++)
        {
            tris[i * 3 + 0] = 0;
            tris[i * 3 + 1] = i + 1;
            tris[i * 3 + 2] = (i + 1) % vertexCount + 1;
        }

        _mesh.vertices  = _curPos;
        _mesh.uv        = uvs;
        _mesh.triangles = tris;
        _mesh.RecalculateNormals();
    }

    private void ApplyTexture()
    {
        var tex = ProceduralCellTexture.Generate(textureSize, textureSeed);

        var mat = new Material(Shader.Find("Sprites/Default"));
        mat.mainTexture = tex;

        GetComponent<MeshRenderer>().material = mat;
    }

    // ── Spring simulation ────────────────────────────────────────────────────

    private void StepSprings()
    {
        float dt = Time.deltaTime;
        for (int i = 1; i < _curPos.Length; i++)   // skip centre vertex
        {
            Vector3 disp   = _curPos[i] - _restPos[i];
            Vector3 force  = (-stiffness * disp) + (-damping * _velocity[i]);
            _velocity[i]  += force * dt;
            _curPos[i]    += _velocity[i] * dt;
        }
    }

    private void UpdateMesh()
    {
        _mesh.vertices = _curPos;
        _mesh.RecalculateNormals();
        _mesh.RecalculateBounds();
    }

    // ── Poke ─────────────────────────────────────────────────────────────────

    /// <summary>
    /// Poke the cell at a local-space position. Nearby vertices get an inward impulse.
    /// Call this from ClickManager on button press, or use the IPointerDownHandler.
    /// </summary>
    public void Poke(Vector2 localPokePos)
    {
        float pokeAngle = Mathf.Atan2(localPokePos.y, localPokePos.x);

        for (int i = 1; i < _curPos.Length; i++)
        {
            float vertAngle = Mathf.Atan2(_restPos[i].y, _restPos[i].x);
            float angleDiff = Mathf.Abs(Mathf.DeltaAngle(
                pokeAngle * Mathf.Rad2Deg,
                vertAngle * Mathf.Rad2Deg)) * Mathf.Deg2Rad;

            if (angleDiff < pokeSpread)
            {
                // Gaussian falloff with angle difference
                float falloff = Mathf.Exp(-(angleDiff * angleDiff) /
                                           (2f * pokeSpread * pokeSpread * 0.3f));
                // Inward = toward centre = negative radial direction
                Vector3 inward = -_restPos[i].normalized;
                _velocity[i] += inward * pokeStrength * falloff;
            }
        }
    }

    // ── Release bounce ───────────────────────────────────────────────────────

    /// <summary>
    /// On release, add a small outward "spring-back" burst at the same point.
    /// </summary>
    public void Release(Vector2 localPokePos)
    {
        float pokeAngle = Mathf.Atan2(localPokePos.y, localPokePos.x);

        for (int i = 1; i < _curPos.Length; i++)
        {
            float vertAngle = Mathf.Atan2(_restPos[i].y, _restPos[i].x);
            float angleDiff = Mathf.Abs(Mathf.DeltaAngle(
                pokeAngle * Mathf.Rad2Deg,
                vertAngle * Mathf.Rad2Deg)) * Mathf.Deg2Rad;

            if (angleDiff < pokeSpread * 1.4f)
            {
                float falloff = Mathf.Exp(-(angleDiff * angleDiff) /
                                           (2f * pokeSpread * pokeSpread * 0.5f));
                Vector3 outward = _restPos[i].normalized;
                _velocity[i] += outward * pokeStrength * 0.35f * falloff;
            }
        }
    }

    // ── IPointerDown/Up — used when SquishyCell itself is the click target ───

    public void OnPointerDown(PointerEventData eventData)
    {
        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(
            (RectTransform)transform, eventData.position,
            eventData.pressEventCamera, out Vector2 local))
        {
            Poke(local);
        }
    }

    public void OnPointerUp(PointerEventData eventData)
    {
        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(
            (RectTransform)transform, eventData.position,
            eventData.pressEventCamera, out Vector2 local))
        {
            Release(local);
        }
    }

    // ── Reset ────────────────────────────────────────────────────────────────

    public void ResetToRest()
    {
        for (int i = 0; i < _curPos.Length; i++)
        {
            _curPos[i]    = _restPos[i];
            _velocity[i]  = Vector3.zero;
        }
    }

    // ── Public: regenerate with different seed / colours ─────────────────────

    public void Regenerate(int seed, Color? membrane = null, Color? cyto = null, Color? nuc = null)
    {
        textureSeed = seed;
        var tex = ProceduralCellTexture.Generate(textureSize, seed, membrane, cyto, nuc);
        GetComponent<MeshRenderer>().material.mainTexture = tex;
    }
}
